## AI Guidance for `tzif-parser`
- Purpose: parse TZif (time zone information) files into Python objects and provide fast `resolve()` lookups that mirror `zoneinfo`. Core entrypoint is `tzif_parser/ tzif.py` with `TimeZoneInfo`.
- Read pipeline: `TimeZoneInfo.read(name)` normalizes/validates the TZ key (rejects absolute paths and traversal), searches `TZDIR` override then default tz paths, falls back to bundled `tzdata` package via `importlib.resources`. `_read_from_fileobj` parses v1 header/body; if version ≥2 it re-reads v2 header/body and POSIX footer.
- File parsing: `tzif_header.py` decodes the fixed header (`>4s1c15x6I`), version byte `\x00` → 1 else ASCII digit; `tzif_body.py` reads transitions, ttinfo structs, abbreviations, leap seconds (marks expiration entries in v4), and flags. Transition times use 32-bit for v1 and 64-bit for v2.
- Transition objects: `TimeZoneInfoBody.transitions` wraps raw data in `tz_transition.TimeZoneTransition`, exposing UTC/local wall/local standard instants, abbreviations, DST flags, and computed DST deltas (prefers neighboring standard ttinfo). `TimeZoneInfoBody.find_transition_index()` and `find_leap_second_index()` accept naive (treated as UTC) or aware datetimes.
- Resolution behavior (`TimeZoneInfo.resolve`): accepts naive (UTC) or aware datetimes; caches last resolution and reuses offsets for ranges before `next_transition`; applies leap-second corrections unless expired; handles four regimes (no transitions, before first, within body, after last). After body end, POSIX footer rules supply offsets/transitions; otherwise sticks to last known offset with no future transitions.
- POSIX footer parsing: `posix.py` reads TZ strings (comma-aware for `<abbr>`), supports M.w.d/Jn/n rules, extended hours and negative times, POSIX sign convention (positive = west/negative seconds). `PosixTz*` helper classes convert POSIX rules to concrete datetimes for a given year.
- Models: `models.py` defines `TimeZoneResolution` return shape plus `TimeTypeInfo`, `LeapSecondTransition`, `WallStandardFlag`. `TimeZoneInfo.body.timezone_abbrevs` deduplicates abbreviations even for mid-string offsets (see `tests/test_tzif.py::test_timezone_abbrevs_include_midstring_indices`).
- Zoneinfo shim: `zoneinfo_shim/` mirrors CPython’s zoneinfo implementation for tests; tests compare parsed data with shim’s internal transition tables, so keep structures aligned with CPython semantics.
- Tests/workflows: install deps with `python -m pip install -r requirements.txt`; run `pytest` from repo root. Functional tests load many zones from system tzdata; failures may indicate missing `/usr/share/zoneinfo` or tzdata package. Perf tests log stats but assert nothing; ensure logging doesn’t spam CI. Some tests skip footer checks if a zone lacks POSIX rules.
- Usage pattern: create with `TimeZoneInfo.read("Area/Location")` or `from_path(abs_path)`; then call `resolve(dt)` or helper accessors (`local`, `is_dst`, `utc_offset_secs`, `next_transition`, etc.). Treat naive datetimes as UTC inputs and expect naive local wall outputs with UTC-aware `resolution_time`.
- Safety/invariants to preserve: maintain `_validate_timezone_key` traversal protections; keep leap-second expiration handling (v4) and corrections in offsets; preserve cache correctness when changing `resolve`; prefer using `TimeZoneInfoBody`/`TimeZoneTransition` helpers instead of re-parsing raw arrays in new code.
- Contributing tips: new parsing logic should mirror CPython’s zoneinfo behaviors (tests compare against real zoneinfo); add targeted pytest cases in `tests/` mirroring sample expectations; keep files ASCII and avoid path traversal or network fetches in core library.
